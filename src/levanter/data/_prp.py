import typing

import jax.numpy as jnp
import jax.random as jrandom  # Import jax.random
import numpy as np


# TODO: do we make this a pytree
class Permutation:
    # Pseudo-Random Permutation Code
    """A stateless pseudo-random permutation.

    This class generates a pseudo-random permutation of a given length. The permutation is generated using a PRNG
    with a fixed key. The permutation is generated by finding a random `a` and `b` such that `gcd(a, length) == 1` and
    then computing the permutation as `p(x) = (a * x + b) % length`.

    This is not a very good PRP, but it is probably good enough for our purposes.
    """
    # TODO: is it actually good enough for our purposes?

    def __init__(self, length, prng_key):
        self.length = length
        # Convert jax.random.PRNGKey to numpy.random.Generator
        self.rng = np.random.Generator(np.random.PCG64(jrandom.randint(prng_key, (), 0, 2**32).item())) # Use jrandom.randint
        self._permutation = None # permutation is generated on demand

    def _generate_permutation(self):
        if self._permutation is None:
            length = self.length
            rng = self.rng

            while True:
                a = rng.integers(1, length)  # a must be in [1, length-1]
                if np.gcd(a, length) == 1:
                    break  # Found a valid 'a'

            b = rng.integers(0, length)  # b can be in [0, length-1]

            permutation = np.empty(length, dtype=np.int64)
            for i in range(length):
                permutation[i] = (a * i + b) % length

            self._permutation = permutation

    @typing.overload
    def __call__(self, indices: int) -> int:
        ...

    @typing.overload
    def __call__(self, indices: np.ndarray) -> np.ndarray:
        ...

    def __call__(self, indices):
        self._generate_permutation() # generate permutation on first call

        was_int = False
        if isinstance(indices, np.ndarray):
            if np.any(indices < 0) or np.any(indices >= self.length):
                raise IndexError(f"index {indices} is out of bounds for length {self.length}")
        else:
            if indices < 0 or indices >= self.length:
                raise IndexError(f"index {indices} is out of bounds for length {self.length}")

            indices = np.array(indices)
            was_int = True

        out = self._permutation[indices]

        if was_int:
            return int(out)
        return out
